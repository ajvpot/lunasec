package process

import (
	"context"
	"crypto/sha256"
	"encoding/json"
	"strings"

	"github.com/PullRequestInc/go-gpt3"
	"github.com/rs/zerolog/log"
)

func (p *processor) GenerateEmbeddingsForContent(cache, vulnID string) error {
	db, err := loadGormDB(cache)
	if err != nil {
		return err
	}

	// not sure this is the right way to do this, but im going to do it anyways for now lol
	searchDB := db
	if vulnID != "" {
		searchDB = db.Where(&ProcessedReference{VulnerabilityID: vulnID})
	}

	var refs []ProcessedReference
	res := searchDB.Find(&refs)
	if res.Error != nil {
		return res.Error
	}

	for _, ref := range refs {
		log.Info().
			Str("url", ref.URL).
			Msg("generating embedding for reference")

		// Split ref normalized content into words, group in chunks of 1024 words
		words := strings.Split(ref.NormalizedContent, " ")
		var chunks [][]string
		for i := 0; i < len(words); i += 1024 {
			end := i + 1024
			if end > len(words) {
				end = len(words)
			}
			chunks = append(chunks, words[i:end])
		}

		for _, chunk := range chunks {
			formattedChunk := strings.Join(chunk, " ")

			// calculate the hash of the chunk
			hash := sha256.Sum256([]byte(formattedChunk))
			hashStr := string(hash[:])

			var referenceEmbedding ReferenceEmbedding
			resp := db.Where(&ReferenceEmbedding{ContentHash: hashStr}).First(&referenceEmbedding)
			if resp.Error == nil {
				// skip this chunk, we already have an embedding for it
				log.Info().Str("url", ref.URL).Msg("skipping chunk, already have embedding")
				continue
			}

			req := gpt3.EmbeddingsRequest{
				Input: []string{formattedChunk},
				Model: gpt3.TextEmbeddingAda002,
			}

			res, err := p.deps.OpenAIClient.Embeddings(context.Background(), req)
			if err != nil {
				log.Error().
					Err(err).
					Str("url", ref.URL).
					Msg("failed to generate embedding")
				return err
			}

			embeddingData, err := json.Marshal(res.Data)
			if err != nil {
				log.Error().
					Err(err).
					Str("url", ref.URL).
					Msg("failed to marshal embedding data")
				return err
			}

			refEmb := ReferenceEmbedding{
				ProcessedReferenceID: ref.ID,
				ContentHash:          hashStr,
				Embedding:            string(embeddingData),
			}
			resp = db.Save(&refEmb)
			if resp.Error != nil {
				log.Error().
					Err(resp.Error).
					Msg("failed to save reference embedding")
				return resp.Error
			}
		}
	}
	return nil
}
