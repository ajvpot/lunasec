package vulnerability

import (
	"context"
	"crypto/tls"
	"database/sql"
	"encoding/json"
	"errors"
	"io"
	golog "log"
	"net/http"
	"net/url"
	"os"
	"path"
	"strings"
	"sync"
	"time"

	md "github.com/JohannesKaufmann/html-to-markdown"
	goose "github.com/advancedlogic/GoOse"
	"github.com/go-jet/jet/v2/postgres"
	"github.com/go-shiori/go-readability"
	"github.com/mozillazg/go-slugify"
	"github.com/rs/zerolog/log"
	"github.com/schollz/progressbar/v3"
	"go.uber.org/fx"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"

	packschem "github.com/lunasec-io/lunasec/lunatrace/gogen/sqlgen/lunatrace/package/table"
	"github.com/lunasec-io/lunasec/lunatrace/gogen/sqlgen/lunatrace/vulnerability/model"
	"github.com/lunasec-io/lunasec/lunatrace/gogen/sqlgen/lunatrace/vulnerability/table"
)

type ProcessedReference struct {
	gorm.Model

	VulnerabilityID string `json:"id"`
	URL             string `json:"url" gorm:"uniqueIndex"`
	Title           string `json:"title"`
	Content         string `json:"content"`
	ContentType     string `json:"content_type"`
	SuccessfulFetch bool   `json:"successful_fetch"`
}

type ProcessedVulnerability struct {
	ID         string               `json:"id"`
	Details    string               `json:"details"`
	Summary    string               `json:"summary"`
	References []ProcessedReference `json:"references"`
}

type VulnerabilityInfo struct {
	model.Vulnerability
	References []model.Reference `json:"references"`
}

type Processor interface {
	ProcessVulnerabilityID(vulnID string) (*ProcessedVulnerability, error)
	ProcessAllVulnerabilities(cache string) error
	LoadAndOutputToDir(cache string, outputDir string, markdown bool) error
}

type processorDeps struct {
	fx.In
	DB *sql.DB
}

type processor struct {
	deps       processorDeps
	httpClient *http.Client
}

func (p *processor) processVulnerability(vulnInfo VulnerabilityInfo) (*ProcessedVulnerability, error) {
	processedVuln := ProcessedVulnerability{
		ID: vulnInfo.SourceID,
	}

	if vulnInfo.Details != nil {
		processedVuln.Details = *vulnInfo.Details
	}
	if vulnInfo.Summary != nil {
		processedVuln.Summary = *vulnInfo.Summary
	}

	for _, ref := range vulnInfo.References {
		req, err := http.NewRequest(http.MethodGet, ref.URL, nil)
		if err != nil {
			log.Error().
				Err(err).
				Str("url", ref.URL).
				Msg("Failed to create request for reference URL")
			continue
		}
		req.Header.Set("User-Agent", "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36")

		resp, err := p.httpClient.Do(req)
		if err != nil {
			log.Error().
				Err(err).
				Str("url", ref.URL).
				Msg("Failed to fetch reference URL")
			continue
		}
		defer resp.Body.Close()

		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			continue
		}

		cp := resp.Header.Get("Content-Type")

		processedVuln.References = append(processedVuln.References, ProcessedReference{
			VulnerabilityID: vulnInfo.SourceID,
			URL:             ref.URL,
			Content:         string(respBody),
			ContentType:     cp,
			SuccessfulFetch: true,
		})
	}
	return &processedVuln, nil
}

func (p *processor) processVulnerabilityWorker(db *gorm.DB, wg *sync.WaitGroup, vulnInfoChan <-chan *VulnerabilityInfo) error {
	for vulnInfo := range vulnInfoChan {
		processed, err := p.processVulnerability(*vulnInfo)
		if err != nil {
			log.Error().Err(err).Msg("failed to process vulnerability")

			ref := ProcessedReference{
				URL:             vulnInfo.References[0].URL,
				SuccessfulFetch: false,
			}
			res := db.Create(&ref)
			if res.Error != nil {
				log.Error().
					Err(res.Error).
					Str("url", ref.URL).
					Msg("failed to insert failed reference")
				continue
			}
			continue
		}

		for _, ref := range processed.References {
			// if the reference has been processed, skip it
			res := db.Where(&ProcessedReference{
				URL: ref.URL,
			}).First(&ProcessedReference{})
			if res.Error == nil {
				// vulnerability has already been processed
				continue
			}

			res = db.Create(&ref)
			if res.Error != nil {
				log.Error().
					Err(res.Error).
					Str("url", ref.URL).
					Msg("failed to insert reference")
				continue
			}
		}
	}
	wg.Done()
	return nil
}

func loadGormDB(cache string) (*gorm.DB, error) {
	newLogger := logger.New(
		golog.New(os.Stdout, "\r\n", golog.LstdFlags),
		logger.Config{
			SlowThreshold:             time.Second,
			LogLevel:                  logger.Silent,
			IgnoreRecordNotFoundError: true,
			Colorful:                  false,
		},
	)
	return gorm.Open(sqlite.Open(cache), &gorm.Config{
		Logger: newLogger,
	})
}

func (p *processor) ProcessAllVulnerabilities(cache string) error {
	db, err := loadGormDB(cache)
	if err != nil {
		return err
	}

	err = db.AutoMigrate(&ProcessedReference{})
	if err != nil {
		return err
	}

	countStmt := table.Vulnerability.SELECT(
		postgres.COUNT(table.Vulnerability.ID),
	)

	var count struct {
		model.Vulnerability
		Count int `json:"count"`
	}

	err = countStmt.Query(p.deps.DB, &count)
	if err != nil {
		return err
	}

	s := table.Vulnerability.SELECT(
		table.Vulnerability.ID,
		table.Vulnerability.SourceID,
		table.Vulnerability.Details,
		table.Vulnerability.Summary,
		table.Reference.URL,
	).FROM(
		table.Vulnerability.INNER_JOIN(
			table.Reference, table.Reference.VulnerabilityID.EQ(table.Vulnerability.ID),
		).INNER_JOIN(
			table.Affected, table.Affected.VulnerabilityID.EQ(table.Vulnerability.ID),
		).INNER_JOIN(
			packschem.Package, packschem.Package.ID.EQ(table.Affected.PackageID),
		),
	).WHERE(
		packschem.Package.PackageManager.EQ(postgres.NewEnumValue("npm")),
	).ORDER_BY(table.Vulnerability.SourceID.DESC())

	rows, err := s.Rows(context.Background(), p.deps.DB)
	if err != nil {
		log.Error().Err(err).Msg("failed to get vulnerability rows")
		return err
	}
	defer rows.Close()

	log.Info().Int("count", count.Count).Msg("processing vulnerabilities")

	bar := progressbar.Default(int64(count.Count))

	vulnInfoChan := make(chan *VulnerabilityInfo, 100)

	var wg sync.WaitGroup

	for i := 0; i < 10; i++ {
		wg.Add(1)
		go func() {
			err := p.processVulnerabilityWorker(db, &wg, vulnInfoChan)
			if err != nil {
				log.Error().Err(err).Msg("failed to process vulnerability worker")
			}
		}()
	}

	for rows.Next() {
		bar.Add(1)

		var vulnInfo struct {
			VulnerabilityInfo
			Reference string `json:"reference"`
		}
		err = rows.Rows.Scan(&vulnInfo.ID, &vulnInfo.SourceID, &vulnInfo.Details, &vulnInfo.Summary, &vulnInfo.Reference)
		if err != nil {
			log.Error().Err(err).Msg("failed to get vulnerability row")
			return err
		}

		vulnURL := "https://lunatrace.lunasec.io/vulnerabilities/" + vulnInfo.SourceID

		existingVulnRef := ProcessedReference{
			URL: vulnURL,
		}

		res := db.Where(&existingVulnRef)
		if res.Error != nil {
			var title string
			var content string
			if vulnInfo.Summary != nil {
				title = *vulnInfo.Summary
			}
			if vulnInfo.Details != nil {
				content = *vulnInfo.Details
			}

			vulnRef := ProcessedReference{
				VulnerabilityID: vulnInfo.SourceID,
				URL:             vulnURL,
				Title:           title,
				Content:         content,
			}

			res = db.Create(&vulnRef)
			if res.Error != nil {
				log.Error().
					Err(res.Error).
					Str("url", vulnRef.URL).
					Msg("failed to create vulnerability reference")
				continue
			}
		}

		// add the reference to the vulnerability, and add the vulnerability to the channel.
		// the channel will be processed by a worker which expects an array of references, but we are currently
		// only processing one reference at a time. (see sql query above)
		vulnInfo.References = append(vulnInfo.References, model.Reference{
			URL: vulnInfo.Reference,
		})
		vulnInfoChan <- &vulnInfo.VulnerabilityInfo
	}

	close(vulnInfoChan)
	log.Info().Msg("waiting for workers to finish")
	wg.Wait()

	return nil
}

func (p *processor) ProcessVulnerabilityID(vulnID string) (*ProcessedVulnerability, error) {
	var vulnInfo VulnerabilityInfo

	s := table.Vulnerability.SELECT(
		table.Vulnerability.SourceID,
		table.Vulnerability.Details,
		table.Vulnerability.Summary,
		table.Reference.URL,
	).FROM(
		table.Vulnerability.INNER_JOIN(
			table.Reference, table.Reference.VulnerabilityID.EQ(table.Vulnerability.ID),
		),
	).WHERE(
		table.Vulnerability.SourceID.EQ(postgres.String(vulnID)),
	)

	err := s.Query(p.deps.DB, &vulnInfo)
	if err != nil {
		log.Error().
			Err(err).
			Str("vuln id", vulnID).
			Msg("Failed to query vulnerability")
		return nil, err
	}
	return p.processVulnerability(vulnInfo)
}

func formatContent(input, nurl string) (content string, err error) {
	defer func() {
		if recover() != nil {
			log.Error().
				Str("nurl", nurl).
				Err(err).
				Msg("unable to format content")
			err = errors.New("unable to format content")
		}
	}()

	g := goose.New()

	// could panic
	gArticle, err := g.ExtractFromRawHTML(input, nurl)
	if err != nil {
		log.Error().
			Err(err).
			Msg("unable to parse html from input")
		return
	}

	converter := md.NewConverter("", true, nil)
	content = "# " + gArticle.Title + "\n\n" + converter.Convert(gArticle.TopNode)
	return
}

func (p *processor) LoadAndOutputToDir(cache string, outputDir string, markdown bool) error {
	db, err := loadGormDB(cache)
	if err != nil {
		return err
	}

	err = os.MkdirAll(outputDir, 0755)
	if err != nil {
		return err
	}

	rows, err := db.Table("processed_references").Rows()
	if err != nil {
		return err
	}
	defer rows.Close()

	for rows.Next() {
		var ref ProcessedReference
		err = db.ScanRows(rows, &ref)
		if err != nil {
			log.Error().Err(err).Msg("failed to scan reference")
			continue
		}

		var (
			content []byte
			ext     string
		)

		contentReader := strings.NewReader(ref.Content)

		parsedUrl, err := url.Parse(ref.URL)
		if err != nil {
			continue
		}

		article, err := readability.FromReader(contentReader, parsedUrl)
		if err != nil {
			log.Error().Err(err).Msg("failed to parse html body")
			continue
		}

		if markdown {
			ext = ".md"

			strContent, err := formatContent(ref.Content, ref.URL)
			if err != nil {
				log.Warn().Err(err).Msg("failed to convert reference to markdown")
				content = []byte("# " + ref.Title + "\n\n" + "## Vulnerability" + "\n" + ref.VulnerabilityID + "\n\n" + article.TextContent)
			} else {
				content = []byte(strContent)
			}
		} else {
			ext = ".json"

			ref.Title = article.Title
			ref.Content = article.TextContent

			content, err = json.Marshal(ref)
			if err != nil {
				log.Error().Err(err).Msg("failed to serialize reference")
				continue
			}
		}

		err = os.WriteFile(path.Join(outputDir, slugify.Slugify(ref.URL)+ext), content, 0644)
		if err != nil {
			log.Error().Err(err).Msg("failed to write reference")
			continue
		}
	}
	return nil
}

func NewProcessor(deps processorDeps) Processor {
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}

	client := &http.Client{Timeout: time.Second * 5, Transport: tr}

	return &processor{
		deps:       deps,
		httpClient: client,
	}
}
