package vulnerability

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"hash/fnv"
	"os"
	"path"
	"sync"
	"time"

	"github.com/go-jet/jet/v2/postgres"
	"github.com/go-shiori/go-readability"
	"github.com/rs/zerolog/log"
	"github.com/schollz/progressbar/v3"
	"go.uber.org/fx"

	"github.com/lunasec-io/lunasec/lunatrace/gogen/sqlgen/lunatrace/vulnerability/model"
	"github.com/lunasec-io/lunasec/lunatrace/gogen/sqlgen/lunatrace/vulnerability/table"
)

type ProcessedReference struct {
	VulnerabilityID string `json:"id"`
	URL             string `json:"url"`
	Title           string `json:"title"`
	Content         string `json:"content"`
}

type ProcessedVulnerability struct {
	ID         string               `json:"id"`
	Details    string               `json:"details"`
	Summary    string               `json:"summary"`
	References []ProcessedReference `json:"references"`
}

type VulnerabilityInfo struct {
	model.Vulnerability
	References []model.Reference `json:"references"`
}

type Processor interface {
	ProcessVulnerabilityID(vulnID string) (*ProcessedVulnerability, error)
	ProcessAllVulnerabilities(outDir string) error
}

type processorDeps struct {
	fx.In
	DB *sql.DB
}

type processor struct {
	deps processorDeps
}

func hashFilename(s string) uint32 {
	h := fnv.New32a()
	h.Write([]byte(s))
	return h.Sum32()
}

func (p *processor) processVulnerability(vulnInfo VulnerabilityInfo) (*ProcessedVulnerability, error) {
	processedVuln := ProcessedVulnerability{
		ID: vulnInfo.SourceID,
	}

	if vulnInfo.Details != nil {
		processedVuln.Details = *vulnInfo.Details
	}
	if vulnInfo.Summary != nil {
		processedVuln.Summary = *vulnInfo.Summary
	}

	for _, ref := range vulnInfo.References {
		article, err := readability.FromURL(ref.URL, 5*time.Second)
		if err != nil {
			log.Error().
				Err(err).
				Str("url", ref.URL).
				Msg("Failed to process reference")
			continue
		}
		processedVuln.References = append(processedVuln.References, ProcessedReference{
			VulnerabilityID: vulnInfo.SourceID,
			URL:             ref.URL,
			Title:           article.Title,
			Content:         article.TextContent,
		})
	}
	return &processedVuln, nil
}

func (p *processor) processVulnerabilityWorker(wg *sync.WaitGroup, outDir string, vulnInfoChan <-chan *VulnerabilityInfo) error {
	for vulnInfo := range vulnInfoChan {
		processed, err := p.processVulnerability(*vulnInfo)
		if err != nil {
			log.Error().Err(err).Msg("failed to process vulnerability")
			continue
		}

		for _, ref := range processed.References {
			content, err := json.MarshalIndent(ref, "", "\t")
			if err != nil {
				log.Error().
					Str("vuln id", vulnInfo.SourceID).
					Str("ref url", ref.URL).
					Err(err).
					Msg("failed to marshal reference")
				continue
			}

			err = os.WriteFile(path.Join(outDir, fmt.Sprintf("%d.json", hashFilename(ref.URL))), content, 0644)
			if err != nil {
				log.Error().
					Str("vuln id", vulnInfo.SourceID).
					Str("ref url", ref.URL).
					Err(err).
					Msg("failed to write reference")
				continue
			}
		}
	}
	wg.Done()
	return nil
}

func (p *processor) ProcessAllVulnerabilities(outDir string) error {
	countStmt := table.Vulnerability.SELECT(
		postgres.COUNT(table.Vulnerability.ID),
	)

	var count struct {
		model.Vulnerability
		Count int `json:"count"`
	}

	err := countStmt.Query(p.deps.DB, &count)
	if err != nil {
		return err
	}

	s := table.Vulnerability.SELECT(
		table.Vulnerability.ID,
		table.Vulnerability.SourceID,
		table.Vulnerability.Details,
		table.Vulnerability.Summary,
		table.Reference.URL,
	).FROM(
		table.Vulnerability.INNER_JOIN(
			table.Reference, table.Reference.VulnerabilityID.EQ(table.Vulnerability.ID),
		),
	).ORDER_BY(table.Vulnerability.SourceID.DESC())

	rows, err := s.Rows(context.Background(), p.deps.DB)
	if err != nil {
		log.Error().Err(err).Msg("failed to get vulnerability rows")
		return err
	}
	defer rows.Close()

	log.Info().Int("count", count.Count).Msg("processing vulnerabilities")

	bar := progressbar.Default(int64(count.Count))

	vulnInfoChan := make(chan *VulnerabilityInfo, 100)

	var wg sync.WaitGroup

	for i := 0; i < 10; i++ {
		wg.Add(1)
		go func() {
			err := p.processVulnerabilityWorker(&wg, outDir, vulnInfoChan)
			if err != nil {
				log.Error().Err(err).Msg("failed to process vulnerability worker")
			}
		}()
	}

	for rows.Next() {
		bar.Add(1)

		var vulnInfo struct {
			VulnerabilityInfo
			Reference string `json:"reference"`
		}
		err = rows.Rows.Scan(&vulnInfo.ID, &vulnInfo.SourceID, &vulnInfo.Details, &vulnInfo.Summary, &vulnInfo.Reference)
		if err != nil {
			log.Error().Err(err).Msg("failed to get vulnerability row")
			return err
		}

		// if the vulnerability has not been processed yet, process and save it
		vulnPath := path.Join(outDir, fmt.Sprintf("%d.json", hashFilename(vulnInfo.SourceID)))
		if _, err := os.Stat(vulnPath); err == nil {
			continue
		}

		var title string
		var content string
		if vulnInfo.Summary != nil {
			title = *vulnInfo.Summary
		}
		if vulnInfo.Details != nil {
			content = *vulnInfo.Details
		}

		vulnRef := ProcessedReference{
			VulnerabilityID: vulnInfo.SourceID,
			URL:             "https://lunatrace.lunasec.io/vulnerabilities/" + vulnInfo.ID.String(),
			Title:           title,
			Content:         content,
		}

		vulnContent, err := json.MarshalIndent(vulnRef, "", "\t")
		if err != nil {
			log.Error().
				Str("vuln id", vulnInfo.SourceID).
				Err(err).
				Msg("failed to marshal vulnerability reference")
			return err
		}

		// hash the file name so we can quickly determine if a vulnerabilty has been processed already
		err = os.WriteFile(vulnPath, vulnContent, 0644)
		if err != nil {
			log.Error().
				Str("vuln id", vulnInfo.SourceID).
				Err(err).
				Msg("failed to write reference")
			return err
		}

		// if the reference has been processed, skip it
		refPath := path.Join(outDir, fmt.Sprintf("%d.json", hashFilename(vulnInfo.Reference)))
		if _, err := os.Stat(refPath); err == nil {
			continue
		}

		vulnInfo.References = append(vulnInfo.References, model.Reference{
			URL: vulnInfo.Reference,
		})
		vulnInfoChan <- &vulnInfo.VulnerabilityInfo
	}

	log.Info().Msg("waiting for workers to finish")
	wg.Wait()

	return nil
}

func (p *processor) ProcessVulnerabilityID(vulnID string) (*ProcessedVulnerability, error) {
	var vulnInfo VulnerabilityInfo

	s := table.Vulnerability.SELECT(
		table.Vulnerability.SourceID,
		table.Vulnerability.Details,
		table.Vulnerability.Summary,
		table.Reference.URL,
	).FROM(
		table.Vulnerability.INNER_JOIN(
			table.Reference, table.Reference.VulnerabilityID.EQ(table.Vulnerability.ID),
		),
	).WHERE(
		table.Vulnerability.SourceID.EQ(postgres.String(vulnID)),
	)

	err := s.Query(p.deps.DB, &vulnInfo)
	if err != nil {
		log.Error().
			Err(err).
			Str("vuln id", vulnID).
			Msg("Failed to query vulnerability")
		return nil, err
	}
	return p.processVulnerability(vulnInfo)
}

func NewProcessor(deps processorDeps) Processor {
	return &processor{
		deps: deps,
	}
}
