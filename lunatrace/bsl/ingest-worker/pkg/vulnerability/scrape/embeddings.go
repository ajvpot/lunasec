package scrape

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/PullRequestInc/go-gpt3"
	"github.com/rs/zerolog/log"
	"github.com/samber/lo"

	"github.com/lunasec-io/lunasec/lunatrace/bsl/ingest-worker/pkg/pineconefx"
)

const (
	maxEmbeddingSize = 1024 * 1024 * 5
)

func newVulnRefVector(hashStr string, embedding []float64, refURL, vulnerabilityID string) *pineconefx.Vector {
	metadata := map[string]string{
		"source":           refURL,
		"vulnerability_id": vulnerabilityID,
	}
	return &pineconefx.Vector{
		ID: hashStr,

		Values: lo.Map(embedding, func(t float64, i int) float32 {
			return float32(t)
		}),
		Metadata: metadata,
	}
}

func (p *scraper) GenerateEmbeddingsForContent(cache, vulnID string) error {
	db, err := loadGormDB(cache)
	if err != nil {
		return err
	}

	// not sure this is the right way to do this, but im going to do it anyways for now lol
	searchDB := db
	if vulnID != "" {
		searchDB = db.Where(&ProcessedReference{VulnerabilityID: vulnID})
	}

	var refs []ProcessedReference
	res := searchDB.Find(&refs)
	if res.Error != nil {
		return res.Error
	}

	var pineconeVectors []*pineconefx.Vector
	for _, ref := range refs {
		if len(ref.NormalizedContent) > maxEmbeddingSize {
			log.Warn().
				Str("url", ref.URL).
				Msg("skipping embedding generation for reference, content too large")
			continue
		}

		log.Info().
			Str("url", ref.URL).
			Msg("generating embedding for reference")

		// Build the content to embed by combining the vulnerability ID, title, and content
		content := fmt.Sprintf("%s %s %s", ref.VulnerabilityID, ref.Title, ref.NormalizedContent)

		// Split ref normalized content into words, group in chunks of 1024 words
		words := strings.Split(content, " ")
		var chunks [][]string
		for i := 0; i < len(words); i += 1024 {
			end := i + 1024
			if end > len(words) {
				end = len(words)
			}
			chunks = append(chunks, words[i:end])
		}

		for _, chunk := range chunks {
			formattedChunk := strings.Join(chunk, " ")

			// calculate the hash of the chunk
			hash := sha256.Sum256([]byte(formattedChunk))
			hashStr := hex.EncodeToString(hash[:])

			var refEmb ReferenceEmbedding
			resp := db.Where(&ReferenceEmbedding{ContentHash: hashStr}).First(&refEmb)
			if resp.Error == nil {
				// skip this chunk, we already have an embedding for it
				log.Info().Str("url", ref.URL).Msg("skipping chunk, already have embedding")

				var embedding []float64
				err = json.Unmarshal([]byte(refEmb.Embedding), &embedding)
				if err != nil {
					log.Error().Err(err).Msg("failed to unmarshal embedding")
					return err
				}

				pineconeVectors = append(pineconeVectors, newVulnRefVector(
					hashStr,
					embedding,
					refEmb.ProcessedReference.URL,
					refEmb.ProcessedReference.VulnerabilityID,
				))
				continue
			}

			req := gpt3.EmbeddingsRequest{
				Input: []string{formattedChunk},
				Model: gpt3.TextEmbeddingAda002,
			}

			res, err := p.deps.OpenAIClient.Embeddings(context.Background(), req)
			if err != nil {
				log.Error().
					Err(err).
					Str("url", ref.URL).
					Msg("failed to generate embedding")
				return err
			}

			// TODO (cthompson) will there be more than just one value in Data? currently we are only sending one chunk at a time.
			embedding := res.Data[0].Embedding
			embeddingData, err := json.Marshal(embedding)
			if err != nil {
				log.Error().
					Err(err).
					Str("url", ref.URL).
					Msg("failed to marshal embedding data")
				return err
			}

			newRefEmb := ReferenceEmbedding{
				ProcessedReferenceID: ref.ID,
				ContentHash:          hashStr,
				Embedding:            string(embeddingData),
			}
			resp = db.Save(&newRefEmb)
			if resp.Error != nil {
				log.Error().
					Err(resp.Error).
					Msg("failed to save reference embedding")
				return resp.Error
			}

			pineconeVectors = append(pineconeVectors, newVulnRefVector(hashStr, embedding, ref.URL, ref.VulnerabilityID))

			// 20 is used in the Buff script, why is it 20?
			if len(pineconeVectors) == 20 {
				log.Info().
					Str("url", ref.URL).
					Msg("upserting embedding to pinecone")

				err = p.deps.PineconeClient.Upsert(pineconeVectors)
				if err != nil {
					log.Error().
						Err(err).
						Msg("failed to upsert pinecone vectors")
					return err
				}
				pineconeVectors = []*pineconefx.Vector{}
			}
		}

		// upsert the remaining vectors to pinecone
		err = p.deps.PineconeClient.Upsert(pineconeVectors)
		if err != nil {
			log.Error().
				Err(err).
				Msg("failed to upsert pinecone vectors")
			return err
		}
	}
	return nil
}
