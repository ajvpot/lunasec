// Copyright by LunaSec (owned by Refinery Labs, Inc)
//
// Licensed under the Business Source License v1.1
// (the "License"); you may not use this file except in compliance with the
// License. You may obtain a copy of the License at
//
// https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
//
// See the License for the specific language governing permissions and
// limitations under the License.
package vulnerability

import (
	"encoding/json"
	"os"

	"github.com/rs/zerolog/log"
	"github.com/urfave/cli/v2"
	"go.uber.org/fx"

	"github.com/lunasec-io/lunasec/lunatrace/bsl/ingest-worker/pkg/vulnerability"

	"github.com/ajvpot/clifx"
)

type Params struct {
	fx.In

	Ingester  vulnerability.FileAdvisoryIngester
	Processor vulnerability.Processor
}

func NewCommand(p Params) clifx.CommandResult {
	return clifx.CommandResult{
		Command: &cli.Command{
			Name: "vulnerability",
			Subcommands: []*cli.Command{
				{
					Name:        "process",
					Description: "Process a file or directory containing vulnerabilities. All references are crawled and their content is downloaded.",
					Flags: []cli.Flag{
						&cli.StringFlag{
							Name:     "db",
							Usage:    "Cache database location",
							Required: false,
						},
					},
					Subcommands: []*cli.Command{
						{
							Name: "cache",
							Action: func(ctx *cli.Context) error {
								cache := ctx.String("db")
								return p.Processor.ProcessAllVulnerabilities(cache)
							},
						},
						{
							Name: "save",
							Flags: []cli.Flag{
								&cli.StringFlag{
									Name:     "out",
									Usage:    "Output file location.",
									Required: false,
								},
								&cli.BoolFlag{
									Name:     "markdown",
									Usage:    "Output in markdown format. Default is json.",
									Required: false,
								},
							},
							Usage: "[vulnerability id]",
							Action: func(ctx *cli.Context) error {
								firstArg := ctx.Args().First()
								out := ctx.String("out")
								markdown := ctx.Bool("markdown")
								cache := ctx.String("db")

								if firstArg == "" {
									return p.Processor.LoadAndOutputToDir(cache, out, markdown)
								}

								vuln, err := p.Processor.ProcessVulnerabilityID(firstArg)
								if err != nil {
									return err
								}
								content, err := json.MarshalIndent(vuln, "", "\t")
								if err != nil {
									return err
								}

								if out != "" {
									err = os.WriteFile(out, content, 0644)
									if err != nil {
										return err
									}
								} else {
									_, err = os.Stdout.Write(content)
									if err != nil {
										return err
									}
								}
								return nil
							},
						},
					},
				},
				{
					Name:  "ingest",
					Usage: "[file or directory]",
					Flags: []cli.Flag{
						&cli.StringFlag{
							Name:     "source",
							Usage:    "Where the vulnerabilities have been sourced from.",
							Required: true,
						},
						&cli.StringFlag{
							Name:  "source-relative-path",
							Usage: "Relative path from within the source to where advisories are located.",
						},
					},
					Subcommands: []*cli.Command{},
					Action: func(ctx *cli.Context) error {
						advisoryLocation := ctx.Args().First()

						source := ctx.String("source")
						sourceRelativePath := ctx.String("source-relative-path")

						log.Info().
							Str("source", source).
							Msg("starting vulnerability ingestion")
						err := p.Ingester.IngestVulnerabilitiesFromSource(advisoryLocation, source, sourceRelativePath)

						if err != nil {
							log.Error().
								Err(err).
								Str("source", source).
								Msg("failed to ingest vulnerabilities")
							return err
						}
						return nil
					},
				},
			},
		},
	}
}
