import { randomUUID } from 'crypto';

import { SeverityNamesOsv } from '@lunatrace/lunatrace-common/build/main';

import { Analysis_Finding_Type_Enum } from '../../hasura-api/generated';
import { notEmpty } from '../../utils/predicates';

import { Graph } from './graph';
import {
  DependencyChain,
  IgnoredVulnerability,
  Manifest,
  ManifestNode,
  TriagedPackageVulnerability,
  VulnerableEdge,
  VulnerableRelease,
} from './types';
import {
  createOrMergeVulnerablePackageRelease,
  isReleaseTriviallyUpdateable,
  VulnerabilityLoader,
} from './vulnerabilities';

const rootNode = '00000000-0000-0000-0000-000000000000';
const nilEdge = '00000000-0000-0000-0000-000000000000';

export default class VulnerabilityDependencyTree {
  private readonly graph: Graph;
  private packageReleaseIdToTriagedVulnerabilities: Map<string, TriagedPackageVulnerability[]> = new Map();
  private nodeIdToNode: Map<string, ManifestNode> = new Map();
  private vulnerableNodes: Set<string> = new Set();
  private nodeReachability: Map<string, Analysis_Finding_Type_Enum> = new Map();

  constructor(
    sourceManifests: Array<Manifest>,
    ignoredVulnerabilities?: IgnoredVulnerability[],
    minimumSeverity?: SeverityNamesOsv
  ) {
    this.graph = new Graph();

    const vulnLoader = new VulnerabilityLoader(ignoredVulnerabilities || [], minimumSeverity || 'Unknown');

    sourceManifests.forEach((manifest) => {
      manifest.child_edges_recursive?.forEach((edge) => {
        const child = edge.child;
        const childId = edge.child_id;
        const parentId = edge.parent_id;

        this.nodeIdToNode.set(childId, child);

        const packageReleaseVulnerabilities = vulnLoader.loadPackageReleaseVulnerabilities(
          child,
          manifest.path || 'Unknown'
        );

        // get existing vulnerabilities for a release, and extend them to include the newly built release vulnerabilities
        const existingReleaseVulnerabilities = this.packageReleaseIdToTriagedVulnerabilities.get(child.release_id);
        this.packageReleaseIdToTriagedVulnerabilities.set(
          child.release_id,
          existingReleaseVulnerabilities
            ? existingReleaseVulnerabilities.concat(packageReleaseVulnerabilities)
            : packageReleaseVulnerabilities
        );

        if (packageReleaseVulnerabilities.length > 0) {
          this.vulnerableNodes.add(childId);
        }

        /*
         find analysis results proving that a path is "not vulnerable" or "not reachable". in other words, we say a node is
         _not_ reachable _only_ when we have explicit analysis results that say that it is not reachable.
         */
        const reachable =
          edge.analysis_results.length > 0 ? edge.analysis_results[0].finding_type : Analysis_Finding_Type_Enum.Unknown;
        this.nodeReachability.set(childId, reachable);

        // TODO (cthompson) the recursive query should return a non-nil edge
        const edgeId = edge.id === nilEdge ? randomUUID() : edge.id;
        this.graph.insertEdge(edgeId, parentId, childId);
      });
    });
  }

  private allDependencyPathsToNodeId(nodeId: string): string[][] {
    const chainsToTraverse: string[][] = [];

    this.graph.inboundNeighbors(nodeId).forEach((parent) => chainsToTraverse.push([parent, nodeId]));

    const dependencyChains = [];
    while (chainsToTraverse.length > 0) {
      const chain = chainsToTraverse.pop();
      if (!chain) {
        continue;
      }

      if (chain[0] === rootNode) {
        dependencyChains.push([rootNode, ...chain]);
        continue;
      }
      const parentNodes = this.graph.inboundNeighbors(chain[0]);
      parentNodes.forEach((parentNode) => chainsToTraverse.push([parentNode, ...chain]));
    }
    return dependencyChains;
  }

  public getEdgesWhereChildIsVulnerable(): VulnerableEdge[] {
    const vulnerableEdges: VulnerableEdge[] = [];

    this.vulnerableNodes.forEach((childId) => {
      const node = this.nodeIdToNode.get(childId);
      if (!node) {
        return;
      }
      const vulnerabilityIds = node.release.package.affected_by_vulnerability.map((v) => v.vulnerability.id);
      this.graph.inboundEdges(childId).forEach((edgeId) => {
        if (edgeId === nilEdge) {
          return;
        }
        vulnerableEdges.push({
          edgeId,
          vulnerabilityIds,
        });
      });
    });
    return vulnerableEdges;
  }

  public getVulnerableReleases(): VulnerableRelease[] {
    const vulnerableReleasesById: Map<string, VulnerableRelease> = new Map();

    this.vulnerableNodes.forEach((nodeId) => {
      const node = this.nodeIdToNode.get(nodeId);
      if (!node) {
        return;
      }

      const packageReleaseVulnerabilities = this.packageReleaseIdToTriagedVulnerabilities.get(node.release_id);
      if (!packageReleaseVulnerabilities) {
        return;
      }

      const vulnerableChains = this.allDependencyPathsToNodeId(nodeId);

      // TODO (cthompson) we should be able to respond with just the node ids for the chain
      // all nodes should be sent back as an array
      const vulnerableNodeChains: DependencyChain[] = vulnerableChains.map((chain) =>
        chain
          .map((nodeId) => {
            const node = this.nodeIdToNode.get(nodeId);
            const reachable = this.nodeReachability.get(nodeId);
            if (!node) {
              return null;
            }
            return {
              ...node,
              reachable: reachable || Analysis_Finding_Type_Enum.Unknown,
            };
          })
          .filter(notEmpty)
      );

      const devOnly = vulnerableChains.every((chain) => {
        const node = this.nodeIdToNode.get(chain[0]);
        if (!node) {
          return false;
        }
        return node.labels && node.labels.scope === 'dev';
      });

      const triviallyUpdatable = isReleaseTriviallyUpdateable(packageReleaseVulnerabilities);

      const existingRelease = vulnerableReleasesById.get(node.release_id);
      packageReleaseVulnerabilities.forEach((releaseVulnerability) => {
        const updatedRelease = createOrMergeVulnerablePackageRelease(
          existingRelease,
          node.release,
          releaseVulnerability,
          vulnerableNodeChains,
          devOnly,
          triviallyUpdatable
        );
        vulnerableReleasesById.set(node.release_id, updatedRelease);
      });
    });
    return [...vulnerableReleasesById.values()];
  }
}
