/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
import { randomUUID } from 'crypto';
import util from 'util';

import { SeverityNamesOsv } from '@lunatrace/lunatrace-common/build/main';

import { Analysis_Finding_Type_Enum } from '../../hasura-api/generated';
import { log } from '../../utils/log';
import { notEmpty } from '../../utils/predicates';

import { Graph } from './graph';
import {
  DependencyChain,
  IgnoredVulnerability,
  Manifest,
  ManifestNode,
  TriagedPackageVulnerability,
  VulnerableEdge,
  VulnerableRelease,
} from './types';
import {
  createOrMergeVulnerablePackageRelease,
  isReleaseTriviallyUpdateable,
  VulnerabilityLoader,
} from './vulnerabilities';

const rootNode = '00000000-0000-0000-0000-000000000000';
const nilEdge = '00000000-0000-0000-0000-000000000000';

export default class VulnerabilityDependencyTree {
  public readonly graph: Graph;
  private packageReleaseIdToTriagedVulnerabilities: Map<string, TriagedPackageVulnerability[]> = new Map();
  private nodeIdToNode: Map<string, ManifestNode> = new Map();
  private vulnerableNodeIds: Set<string> = new Set();
  private nodeReachability: Map<string, Analysis_Finding_Type_Enum> = new Map();

  constructor(
    sourceManifests: Array<Manifest>,
    ignoredVulnerabilities?: IgnoredVulnerability[],
    minimumSeverity?: SeverityNamesOsv
  ) {
    this.graph = new Graph();

    const vulnLoader = new VulnerabilityLoader(ignoredVulnerabilities || [], minimumSeverity || 'Unknown');

    sourceManifests.forEach((manifest) => {
      manifest.child_edges_recursive?.forEach((edge) => {
        const node = edge.child;
        const childId = edge.child_id;
        const parentId = edge.parent_id;

        this.nodeIdToNode.set(childId, node);

        const packageReleaseVulnerabilities = vulnLoader.loadPackageReleaseVulnerabilities(
          node,
          manifest.path || 'Unknown'
        );

        // get existing vulnerabilities for a release, and extend them to include the newly built release vulnerabilities
        const existingReleaseVulnerabilities = this.packageReleaseIdToTriagedVulnerabilities.get(node.release_id);
        this.packageReleaseIdToTriagedVulnerabilities.set(
          node.release_id,
          existingReleaseVulnerabilities
            ? existingReleaseVulnerabilities.concat(packageReleaseVulnerabilities)
            : packageReleaseVulnerabilities
        );

        if (packageReleaseVulnerabilities.length > 0) {
          this.vulnerableNodeIds.add(childId); // dupes will be handled by the Set
        }

        /*
         find analysis results proving that a path is "not vulnerable" or "not reachable". in other words, we say a node is
         _not_ reachable _only_ when we have explicit analysis results that say that it is not reachable.
         */
        const reachable =
          edge.analysis_results.length > 0 ? edge.analysis_results[0].finding_type : Analysis_Finding_Type_Enum.Unknown;
        this.nodeReachability.set(childId, reachable);

        // TODO (cthompson) the recursive query should return a non-nil edge
        const edgeId = edge.id === nilEdge ? randomUUID() : edge.id;

        this.graph.insertEdge(edgeId, parentId, childId);
      });
    });
  }

  private allDependencyPathsToNodeId(nodeId: string): string[][] {
    const chainsToTraverse: string[][] = [];

    this.graph.getParentIds(nodeId).forEach((parent) => chainsToTraverse.push([parent, nodeId]));

    const dependencyChains = [];
    while (chainsToTraverse.length > 0) {
      const chain = chainsToTraverse.pop();
      if (!chain) {
        continue;
      }

      if (chain[0] === rootNode) {
        dependencyChains.push([rootNode, ...chain]);
        continue;
      }
      const parentNodes = this.graph.getParentIds(chain[0]);
      parentNodes.forEach((parentNode) => chainsToTraverse.push([parentNode, ...chain]));
    }
    return dependencyChains;
  }

  public getEdgesWhereChildIsVulnerable(): VulnerableEdge[] {
    const vulnerableEdges: VulnerableEdge[] = [];

    this.vulnerableNodeIds.forEach((childId) => {
      const node = this.nodeIdToNode.get(childId);
      if (!node) {
        return;
      }
      const vulnerabilityIds = node.release.package.affected_by_vulnerability.map((v) => v.vulnerability.id);
      this.graph.getNodeEdgeIds(childId).forEach((edgeId) => {
        if (edgeId === nilEdge) {
          return;
        }
        vulnerableEdges.push({
          edgeId,
          vulnerabilityIds,
        });
      });
    });
    return vulnerableEdges;
  }

  public getVulnerableReleases(): VulnerableRelease[] {
    const vulnerableReleasesById: Map<string, VulnerableRelease> = new Map();

    this.vulnerableNodeIds.forEach((nodeId) => {
      const node = this.nodeIdToNode.get(nodeId);
      if (!node) {
        return;
      }

      const packageReleaseVulnerabilities = this.packageReleaseIdToTriagedVulnerabilities.get(node.release_id);
      if (!packageReleaseVulnerabilities) {
        return;
      }

      const chainIdStrings = this.allDependencyPathsToNodeId(nodeId);

      // TODO (cthompson) we should be able to respond with just the node ids for the chain
      // all nodes should be sent back as an array
      const chains: DependencyChain[] = chainIdStrings.map((chain) => {
        return chain
          .map((nodeId) => {
            const node = this.nodeIdToNode.get(nodeId);
            const reachable = this.nodeReachability.get(nodeId);
            if (!node) {
              return null;
            }
            return {
              ...node,
              reachable: reachable || Analysis_Finding_Type_Enum.Unknown,
            };
          })
          .filter(notEmpty);
      });

      const devOnly = chainIdStrings.every((chain) => {
        const node = this.nodeIdToNode.get(chain[0]);
        if (!node) {
          return false;
        }
        return node.labels && node.labels.scope === 'dev';
      });

      const triviallyUpdatable = isReleaseTriviallyUpdateable(packageReleaseVulnerabilities);

      // loop each vulnerability on the node
      packageReleaseVulnerabilities.forEach((releaseVulnerability, index) => {
        const existingRelease = vulnerableReleasesById.get(node.release_id);
        const isFirstVulnOnNode = index === 0;

        const upsertedRelease = createOrMergeVulnerablePackageRelease(
          existingRelease,
          node.release,
          releaseVulnerability,
          isFirstVulnOnNode ? chains : [],
          devOnly,
          triviallyUpdatable
        );
        vulnerableReleasesById.set(node.release_id, upsertedRelease);
      });
    });
    return Array.from(vulnerableReleasesById.values());
  }
}
