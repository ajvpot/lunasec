import { randomUUID } from 'crypto';

import { SeverityNamesOsv } from '@lunatrace/lunatrace-common/build/main';
import { DirectedGraph } from 'graphology';

import { notEmpty } from '../../utils/predicates';

import {
  IgnoredVulnerability,
  Manifest,
  ManifestNode,
  TriagedPackageVulnerability,
  VulnerableEdge,
  VulnerableRelease,
} from './types';
import {
  createOrMergeVulnerablePackageRelease,
  isReleaseTriviallyUpdateable,
  loadPackageReleaseVulnerabilities,
} from './vulnerabilities';

const rootNode = '00000000-0000-0000-0000-000000000000';
const nilEdge = '00000000-0000-0000-0000-000000000000';

export default class VulnerabilityDependencyTree {
  private readonly graph: DirectedGraph;
  private packageReleaseIdToTriagedVulnerabilities: Map<string, TriagedPackageVulnerability[]> = new Map();
  private nodeIdToNode: Map<string, ManifestNode> = new Map();

  constructor(
    sourceManifests: Array<Manifest>,
    ignoredVulnerabilities?: IgnoredVulnerability[],
    minimumSeverity?: SeverityNamesOsv
  ) {
    this.graph = new DirectedGraph();

    sourceManifests.forEach((manifest) => {
      manifest.child_edges_recursive?.forEach((edge) => {
        const child = edge.child;
        const childId = edge.child_id;
        const parentId = edge.parent_id;

        this.nodeIdToNode.set(childId, child);

        const packageReleaseVulnerabilities = loadPackageReleaseVulnerabilities(
          child,
          manifest.path || 'Unknown',
          ignoredVulnerabilities || [],
          minimumSeverity || 'Unknown'
        );

        // get existing vulnerabilities for a release, and extend them to include the newly built release vulnerabilities
        const existingReleaseVulnerabilities = this.packageReleaseIdToTriagedVulnerabilities.get(child.release_id);
        this.packageReleaseIdToTriagedVulnerabilities.set(
          child.release_id,
          existingReleaseVulnerabilities
            ? existingReleaseVulnerabilities.concat(packageReleaseVulnerabilities)
            : packageReleaseVulnerabilities
        );

        this.graph.mergeNode(parentId);
        this.graph.mergeNode(childId, {
          hasVulnerabilities: packageReleaseVulnerabilities.length > 0,
        });

        // TODO (cthompson) the recursive query should return a non-nil edge
        const edgeId = edge.id === nilEdge ? randomUUID() : edge.id;
        this.graph.addEdgeWithKey(edgeId, parentId, childId, {
          childHasVulnerabilities: packageReleaseVulnerabilities.length > 0,
        });
      });
    });
  }

  private allDependencyPathsToNodeId(nodeId: string): string[][] {
    const chainsToTraverse = this.graph.inboundNeighbors(nodeId).map((parent) => [parent, nodeId]);
    const dependencyChains = [];
    while (chainsToTraverse.length > 0) {
      const chain = chainsToTraverse.pop();
      if (!chain) {
        continue;
      }

      if (chain[0] === rootNode) {
        dependencyChains.push([rootNode, ...chain]);
        continue;
      }
      const parentNodes = this.graph.inboundNeighbors(chain[0]);
      parentNodes.forEach((parentNode) => chainsToTraverse.push([parentNode, ...chain]));
    }
    return dependencyChains;
  }

  public getEdgesWhereChildIsVulnerable(): VulnerableEdge[] {
    const vulnerableEdges: VulnerableEdge[] = [];

    this.graph.forEachNode((childId, attributes) => {
      if (!attributes.hasVulnerabilities) {
        return;
      }
      const node = this.nodeIdToNode.get(childId);
      if (!node) {
        return;
      }
      const vulnerabilityIds = node.release.package.affected_by_vulnerability.map((v) => v.vulnerability.id);
      const edgesWithVulnerabilities = this.graph
        .inboundEdges(childId)
        .filter((edgeId) => edgeId === nilEdge)
        .map((edgeId) => ({
          edgeId,
          vulnerabilityIds,
        }));
      vulnerableEdges.concat(edgesWithVulnerabilities);
    });
    return vulnerableEdges;
  }

  public getVulnerableReleases(): VulnerableRelease[] {
    const vulnerableReleasesById: Map<string, VulnerableRelease> = new Map();
    this.graph.forEachNode((nodeId, attributes) => {
      if (!attributes.hasVulnerabilities) {
        return;
      }

      const node = this.nodeIdToNode.get(nodeId);
      if (!node) {
        return;
      }

      const packageReleaseVulnerabilities = this.packageReleaseIdToTriagedVulnerabilities.get(node.release_id);
      if (!packageReleaseVulnerabilities) {
        return;
      }

      const vulnerableChains = this.allDependencyPathsToNodeId(nodeId);

      // TODO (cthompson) we should be able to respond with just the node ids for the chain
      // all nodes should be sent back as an array
      const vulnerableNodeChains = vulnerableChains.map((chain) =>
        chain.map((nodeId) => this.nodeIdToNode.get(nodeId)).filter(notEmpty)
      );

      const devOnly = vulnerableChains.every((chain) => {
        const node = this.nodeIdToNode.get(chain[0]);
        if (!node) {
          return false;
        }
        return node.labels && node.labels.scope === 'dev';
      });

      const triviallyUpdateable = isReleaseTriviallyUpdateable(packageReleaseVulnerabilities);

      const existingRelease = vulnerableReleasesById.get(node.release_id);
      packageReleaseVulnerabilities.forEach((releaseVulnerability) => {
        const updatedRelease = createOrMergeVulnerablePackageRelease(
          existingRelease,
          node.release,
          releaseVulnerability,
          vulnerableNodeChains,
          devOnly,
          triviallyUpdateable
        );
        vulnerableReleasesById.set(node.release_id, updatedRelease);
      });
    });
    return [...vulnerableReleasesById.values()];
  }
}
