// Copyright by LunaSec (owned by Refinery Labs, Inc)
//
// Licensed under the Business Source License v1.1 
// (the "License"); you may not use this file except in compliance with the
// License. You may obtain a copy of the License at
//
// https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
package vulnerability

import (
  "context"
  "encoding/json"
  "fmt"
  "github.com/Khan/genqlient/graphql"
  "github.com/lunasec-io/lunasec/lunatrace/bsl/license-worker/pkg/vulnerability/schema"
  "github.com/lunasec-io/lunasec/lunatrace/cli/gql"
  "github.com/rs/zerolog/log"
  "github.com/vektah/gqlparser/v2/gqlerror"
  "go.uber.org/fx"
  "io/ioutil"
)

type Loader interface {
  Load(ctx context.Context, filename string) error
}

type Params struct {
  fx.In

  GQLClient graphql.Client
}

type OSVLoader struct {
  Params
}

func NewOSVLoader(params Params) Loader {
  return &OSVLoader{
    Params: params,
  }
}

func (i *OSVLoader) Load(ctx context.Context, filename string) (err error) {
  var (
    vulnerability schema.OsvSchema
  )

  content, err := ioutil.ReadFile(filename)
  if err != nil {
    log.Error().
      Err(err).
      Str("filename", filename).
      Msg("unable to read vulnerability file")
    return
  }

  err = json.Unmarshal(content, &vulnerability)
  if err != nil {
    log.Error().
      Err(err).
      Str("filename", filename).
      Msg("unable to unmarshal file")
    return
  }

  vulnerabilityInput, err := MapOsvToGraphql("ghsa", &vulnerability)
  if err != nil {
    log.Error().
      Err(err).
      Str("filename", filename).
      Msg("unable to map osv to graphql insert")
    return
  }

  resp, err := gql.UpsertVulnerability(ctx, i.GQLClient, vulnerabilityInput, gql.VulnerabilityOnConflict)
  if err != nil {
    if gqlErrorList, ok := err.(gqlerror.List); ok {
      var errorMsgs []string
      for _, err := range gqlErrorList {
        errorMsgs = append(errorMsgs, fmt.Sprintf("%v", err.Extensions))
      }
      log.Error().
        Err(err).
        Strs("context", errorMsgs).
        Str("filename", filename).
        Msg("unable to insert vulnerability")
      return
    }
    log.Error().
      Err(err).
      Str("filename", filename).
      Msg("unable to insert vulnerability")
    return
  }

  insertedId := resp.GetInsert_vulnerability_one().Id
  log.Info().Str("id", insertedId.String()).Msg("inserted vulnerability")
  return
}
